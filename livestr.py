# -*- coding: utf-8 -*-
"""Live Straddle Dashboard

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1y09F1rK8qWfpjTPpTHIyCNFllXcAUOEG
"""

import asyncio
import math
import os
import socket
from datetime import datetime

from ib_async import IB, Index, Option

# --- CONFIGURATION ---
PORT = 7496  # 7497 (Paper) or 7496 (Live)
CLIENT_ID = 3  # Ensure this is unique
UNDERLYING = "SPX"
EXCHANGE = "CBOE"


def clear_screen():
    os.system("cls" if os.name == "nt" else "clear")


def get_nearest_strike(price, step=5):
    """Rounds price to the nearest strike interval (default 5 for SPX)."""
    return step * round(price / step)


async def get_next_n_spxw_expiries(ib, contract, n=6):
    """
    Fetches option chains, looks for SPXW, and returns the next N expirations.
    Returns a list of (expiry_date, trading_class).
    """
    if not contract.conId:
        await ib.qualifyContractsAsync(contract)

    print(f"Fetching Option Chains for {contract.symbol}...")
    chains = await ib.reqSecDefOptParamsAsync(
        contract.symbol, "", contract.secType, contract.conId
    )

    # Filter for SPXW (PM Settled) on SMART or CBOE
    spxw_chains = [
        c for c in chains if c.tradingClass == "SPXW" and c.exchange == "SMART"
    ]

    # Fallback if specific SPXW logic fails (rare for SPX)
    if not spxw_chains:
        print("Warning: No SPXW chains found. Falling back to standard search.")
        spxw_chains = [c for c in chains if c.exchange == "SMART"]

    all_expirations = set()
    for chain in spxw_chains:
        all_expirations.update(chain.expirations)

    sorted_exp = sorted(list(all_expirations))

    # Filter for today and future
    now_str = datetime.now().strftime("%Y%m%d")
    future_exps = [e for e in sorted_exp if e >= now_str]

    # Select top N
    selected = future_exps[:n]

    # Return list of (expiry, tradingClass)
    t_class = spxw_chains[0].tradingClass if spxw_chains else "SPX"

    return [(exp, t_class) for exp in selected]


def get_greeks(ticker):
    """
    Safely extracts Implied Vol, Gamma, and Theta from a ticker's modelGreeks.
    Returns (iv, gamma, theta) or (0, 0, 0) if not available.
    """
    if ticker.modelGreeks:
        iv = ticker.modelGreeks.impliedVol if ticker.modelGreeks.impliedVol else 0.0
        gamma = ticker.modelGreeks.gamma if ticker.modelGreeks.gamma else 0.0
        theta = ticker.modelGreeks.theta if ticker.modelGreeks.theta else 0.0
        return iv, gamma, theta
    return 0.0, 0.0, 0.0


def check_port_open(host, port):
    """Check if a port is open and accepting connections."""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(2)
        result = sock.connect_ex((host, port))
        sock.close()
        return result == 0
    except Exception:
        return False


async def main():
    ib = IB()

    print(f"Connecting to TWS/IB Gateway on port {PORT}...")
    print(f"  Host: 127.0.0.1")
    print(f"  Port: {PORT} ({'Live' if PORT == 7496 else 'Paper'})")
    print(f"  Client ID: {CLIENT_ID}")

    # Check if port is open before attempting connection
    print(f"\nChecking if port {PORT} is open...")
    if not check_port_open("127.0.0.1", PORT):
        print(f"âŒ Port {PORT} is not accepting connections")
        print(f"\nðŸ“‹ Troubleshooting Steps:")
        print(f"   1. Make sure TWS or IB Gateway is running")
        print(f"   2. In TWS/IB Gateway, go to:")
        print(f"      Configure â†’ API â†’ Settings")
        print(f"   3. Enable 'Enable ActiveX and Socket Clients'")
        print(f"   4. Set 'Socket port' to {PORT}")
        print(f"   5. Add '127.0.0.1' to 'Trusted IPs' (or leave empty for localhost)")
        print(f"   6. Restart TWS/IB Gateway after making changes")
        print(f"\n   Note: Port 7496 = Live, Port 7497 = Paper Trading")
        return
    else:
        print(f"âœ“ Port {PORT} is open")

    print()
    try:
        await ib.connectAsync("127.0.0.1", PORT, clientId=CLIENT_ID)
        print("âœ“ Connected successfully!")
    except ConnectionRefusedError as e:
        print(f"\nâŒ Connection Refused Error:")
        print(f"   {e}")
        print(f"\nðŸ“‹ Troubleshooting Steps:")
        print(f"   1. Make sure TWS or IB Gateway is running")
        print(f"   2. In TWS/IB Gateway, go to:")
        print(f"      Configure â†’ API â†’ Settings")
        print(f"   3. Enable 'Enable ActiveX and Socket Clients'")
        print(f"   4. Set 'Socket port' to {PORT}")
        print(f"   5. Add '127.0.0.1' to 'Trusted IPs' (or leave empty for localhost)")
        print(f"   6. Restart TWS/IB Gateway after making changes")
        print(f"\n   Note: Port 7496 = Live, Port 7497 = Paper Trading")
        return
    except Exception as e:
        print(f"\nâŒ Connection failed: {e}")
        print(f"\nðŸ“‹ Make sure:")
        print(f"   - TWS/IB Gateway is running")
        print(f"   - API is enabled in TWS/IB Gateway settings")
        print(f"   - Port {PORT} matches the configured API port")
        return

    # Request Delayed (3) or Live (1) data.
    # Note: Greeks might not populate on Delayed (Type 3) data depending on TWS subscription.
    ib.reqMarketDataType(3)

    # 1. GET UNDERLYING PRICE
    print(f"Fetching {UNDERLYING} price...")
    spx = Index(UNDERLYING, EXCHANGE)
    await ib.qualifyContractsAsync(spx)

    spx_ticker = ib.reqMktData(spx, "", False, False)

    print("Waiting for data stream...")
    attempts = 0

    def is_valid_price(val):
        """Check if price is a valid positive number (not NaN)."""
        return val and isinstance(val, float) and not math.isnan(val) and val > 0

    while not (is_valid_price(spx_ticker.last) or is_valid_price(spx_ticker.close)):
        await asyncio.sleep(0.2)
        attempts += 1
        if attempts > 50:
            print("Timeout waiting for SPX data. Check subscription.")
            return

    # 2. GET EXPIRIES (0DTE to 5DTE)
    expiries_info = await get_next_n_spxw_expiries(ib, spx, n=6)

    if not expiries_info:
        print("Error: Could not find expirations.")
        return

    print(f"Found {len(expiries_info)} expirations: {[e[0] for e in expiries_info]}")
    print("Starting Live Multi-DTE Dashboard...")

    # State variables
    current_atm_strike = 0
    tickers_map = {}  # Key: expiry, Value: dict of data
    active_tickers_list = []
    first_run = True

    # --- MAIN LOOP START ---
    try:
        while ib.isConnected():
            clear_screen()

            # Refresh Underlying
            cur_spot = (
                spx_ticker.last if is_valid_price(spx_ticker.last) else spx_ticker.close
            )
            if not is_valid_price(cur_spot):
                cur_spot = 0.0

            # --- DYNAMIC STRIKE LOGIC ---
            target_strike = get_nearest_strike(cur_spot)

            # If the strike has moved (or it's the first run), update contracts
            if target_strike != current_atm_strike and target_strike > 0:
                print(
                    f"Strike Update: Moving from {current_atm_strike} to {target_strike}..."
                )

                # 1. Cleanup old data
                for t in active_tickers_list:
                    ib.cancelMktData(t.contract)
                active_tickers_list = []
                tickers_map = {}

                # 2. Build new contracts
                contracts = []
                for i, (expiry, t_class) in enumerate(expiries_info):
                    c = Option(
                        UNDERLYING,
                        expiry,
                        target_strike,
                        "C",
                        "SMART",
                        tradingClass=t_class,
                    )
                    p = Option(
                        UNDERLYING,
                        expiry,
                        target_strike,
                        "P",
                        "SMART",
                        tradingClass=t_class,
                    )
                    contracts.extend([c, p])

                # 3. Qualify (resolve IDs)
                try:
                    contracts = await ib.qualifyContractsAsync(*contracts)
                except Exception as e:
                    print(f"Error qualifying contracts for strike {target_strike}: {e}")
                    await asyncio.sleep(5)
                    continue

                # 4. Request new data
                for i in range(0, len(contracts), 2):
                    call_c = contracts[i]
                    put_c = contracts[i + 1]

                    # Generic Ticks: 100 (Vol), 101 (OI), 104 (HistVol), 106 (ImpVol)
                    # Adding generic ticks helps force greek updates on some connections
                    c_ticker = ib.reqMktData(call_c, "100,101,104,106", False, False)
                    p_ticker = ib.reqMktData(put_c, "100,101,104,106", False, False)

                    active_tickers_list.extend([c_ticker, p_ticker])

                    # Map for display
                    expiry_date = call_c.lastTradeDateOrContractMonth
                    dte_index = i // 2
                    tickers_map[expiry_date] = {
                        "dte_label": f"{dte_index}DTE",
                        "call": c_ticker,
                        "put": p_ticker,
                    }

                current_atm_strike = target_strike
                print("Contracts updated. Waiting for quotes and greeks...")
                await asyncio.sleep(2)
                clear_screen()

            # --- DISPLAY DASHBOARD ---
            print(f"=== SPX ATM STRADDLE MONITOR ===")
            print(f"Spot Price:   {cur_spot:.2f}")
            print(f"Active Strike:{current_atm_strike}")
            print("-" * 115)
            # Expanded Header
            print(
                f"{'DTE':<5} | {'EXPIRY':<9} | {'C-BID':<7} {'C-ASK':<7} | {'P-BID':<7} {'P-ASK':<7} | {'STRADDLE':<9} | {'IV':<6} | {'GAMMA':<7} | {'THETA':<7}"
            )
            print("-" * 115)

            for i, (expiry, _) in enumerate(expiries_info):
                if expiry not in tickers_map:
                    continue

                data = tickers_map[expiry]
                c_tick = data["call"]
                p_tick = data["put"]
                label = data["dte_label"]

                # Price Helper
                def get_prices(t):
                    b = t.bid if is_valid_price(t.bid) else 0.0
                    a = t.ask if is_valid_price(t.ask) else 0.0
                    return b, a

                cb, ca = get_prices(c_tick)
                pb, pa = get_prices(p_tick)

                # Mid Prices
                cm = (cb + ca) / 2 if (cb > 0 and ca > 0) else 0.0
                pm = (pb + pa) / 2 if (pb > 0 and pa > 0) else 0.0

                cost = cm + pm

                # --- GREEKS CALCULATION ---
                c_iv, c_gamma, c_theta = get_greeks(c_tick)
                p_iv, p_gamma, p_theta = get_greeks(p_tick)

                # Straddle Greeks
                # IV: Average of Call and Put IV
                if c_iv > 0 and p_iv > 0:
                    straddle_iv = (c_iv + p_iv) / 2
                else:
                    straddle_iv = c_iv or p_iv  # Fallback to whichever exists

                # Greeks are additive
                straddle_gamma = c_gamma + p_gamma
                straddle_theta = c_theta + p_theta

                print(
                    f"{label:<5} | {expiry:<9} | {cb:>7.2f} {ca:>7.2f} | {pb:>7.2f} {pa:>7.2f} | ${cost:>8.2f} | {straddle_iv:>6.1%} | {straddle_gamma:>7.4f} | {straddle_theta:>7.2f}"
                )

            print("-" * 115)

            if first_run:
                print("Next update in 5 seconds...")
                await asyncio.sleep(5)
                first_run = False
            else:
                print("Press Ctrl+C to stop (Updates every 5 minutes)")
                await asyncio.sleep(300)

    except Exception as e:
        print(f"Loop error: {e}")
    # --- MAIN LOOP END ---


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nExiting...")
